generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  userId        String   @id
  walletAddress String?  @unique  // Endereço principal (legado)
  displayName   String?
  attributes    Json?
  tenantId      String
  createdAt     DateTime @default(now())
  lastSeenAt    DateTime?

  // Relacionamentos
  Conversations Conversation[]
  DcaSessions   DcaSession[]
  DcaWorkflows  DcaWorkflow[]
  DcaHistories  DcaHistory[]
  Wallets       Wallet[]       // Múltiplas carteiras do usuário
}

model Conversation {
  id             String   @id @default(cuid())
  userId         String
  conversationId String
  title          String?
  status         String   @default("active")
  currentAgent   String?
  lastMessageId  String?
  contextState   Json     @default("{}")
  memoryState    Json     @default("{}")
  messageCount   Int      @default(0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @default(now())
  closedAt       DateTime?
  tenantId       String

  user User @relation(fields: [userId], references: [userId])
  messages Message[]

  @@unique([userId, conversationId])
}

model Message {
  messageId        String   @id @default(uuid())
  userId           String
  conversationId   String
  role             String
  content          String
  agentName        String?
  agentType        String?
  requiresAction   Boolean  @default(false)
  actionType       String?
  metadata         Json     @default("{}")
  status           String   @default("completed")
  errorMessage     String?
  toolCalls        Json?
  toolResults      Json?
  nextAgent        String?
  requiresFollowup Boolean  @default(false)
  timestamp        DateTime @default(now())
  tenantId         String

  conversation Conversation @relation(fields: [userId, conversationId], references: [userId, conversationId])
  toolCallsRel  MessageToolCall[]

  @@index([userId, conversationId, timestamp])
}

model MessageToolCall {
  toolCallId   String   @id @default(uuid())
  messageId    String
  toolName     String
  args         Json
  result       Json?
  errorMessage String?
  latencyMs    Int?
  createdAt    DateTime @default(now())

  message Message @relation(fields: [messageId], references: [messageId])
}

model AgentTurn {
  turnId        String   @id @default(uuid())
  userId        String
  conversationId String
  agentName     String
  agentType     String?
  startedAt     DateTime @default(now())
  endedAt       DateTime?
  success       Boolean  @default(true)
  errorMessage  String?
  metadata      Json     @default("{}")
  tenantId      String
}

model AgentSharedState {
  agentName      String
  userId         String
  conversationId String
  state          Json     @default("{}")
  updatedAt      DateTime @default(now())
  tenantId       String

  @@id([agentName, userId, conversationId])
}

model ConversationMemory {
  memoryId         String   @id @default(uuid())
  userId           String
  conversationId   String?
  scope            String
  memoryType       String
  label            String?
  payload          Json
  embedding        Bytes?
  importanceScore  Float?
  expiresAt        DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @default(now())
  tenantId         String
}

model SwapSession {
  userId          String
  conversationId  String
  status          String
  event           String
  intent          Json
  missingFields   String[]
  nextField       String?
  pendingQuestion String?
  choices         Json?
  errorMessage    String?
  historyCursor   Int       @default(0)
  updatedAt       DateTime  @default(now())
  tenantId        String

  @@id([userId, conversationId])
}

model SwapHistory {
  historyId       String   @id @default(uuid())
  userId          String
  conversationId  String
  status          String
  fromNetwork     String?
  fromToken       String?
  toNetwork       String?
  toToken         String?
  amount          Float?
  errorMessage    String?
  recordedAt      DateTime @default(now())
  tenantId        String
}

model DcaSession {
  userId          String
  conversationId  String
  status          String
  stage           String?
  event           String?
  intent          Json
  missingFields   String[]
  nextField       String?
  pendingQuestion String?
  choices         Json?
  errorMessage    String?
  historyCursor   Int       @default(0)
  updatedAt       DateTime  @default(now())
  tenantId        String

  user User @relation(fields: [userId], references: [userId])

  @@id([userId, conversationId])
  @@index([userId, conversationId, updatedAt])
}

model DcaHistory {
  historyId      String   @id @default(uuid())
  userId         String
  conversationId String
  summary        String?
  workflowType   String?
  cadence        Json?
  tokens         Json?
  amounts        Json?
  strategy       Json?
  venue          String?
  slippageBps    Int?
  stopConditions Json?
  metadata       Json?
  errorMessage   String?
  recordedAt     DateTime @default(now())
  tenantId       String

  user User @relation(fields: [userId], references: [userId])

  @@index([userId, conversationId, recordedAt])
}

model DcaWorkflow {
  workflowId      String   @id @default(uuid())
  userId          String
  conversationId  String?
  walletAddress   String?
  status          String
  strategyId      String?
  strategyVersion String?
  strategyName    String?
  strategy        Json?
  cadence         Json?
  tokens          Json?
  amounts         Json?
  metadata        Json?
  guardrails      Json?
  nextRunAt       DateTime?
  lastRunAt       DateTime?
  pausedAt        DateTime?
  cancelledAt     DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  tenantId        String

  user User @relation(fields: [userId], references: [userId])
  runs DcaRun[]

  @@index([userId, status])
  @@index([nextRunAt])
}

model DcaRun {
  runId          String   @id @default(uuid())
  workflowId     String
  status         String
  executedAt     DateTime @default(now())
  txHash         String?
  amountExecuted Json?
  errorMessage   String?
  metadata       Json?
  createdAt      DateTime @default(now())
  tenantId       String

  workflow DcaWorkflow @relation(fields: [workflowId], references: [workflowId])

  @@index([workflowId, executedAt])
}

model AgentMetric {
  metricId        String   @id @default(uuid())
  agentName       String
  agentType       String?
  userId          String?
  conversationId  String?
  responseTimeMs  Int?
  success         Boolean
  errorMessage    String?
  tokensInput     Int?
  tokensOutput    Int?
  createdAt       DateTime @default(now())
  tenantId        String
}

model Outbox {
  id          String   @id @default(uuid())
  entity      String
  op          String
  payload     Json
  occurredAt  DateTime @default(now())
  processedAt DateTime?
  attempts    Int       @default(0)
}

model IdempotencyKey {
  key         String   @id
  requestHash String
  response    Json
  createdAt   DateTime @default(now())
}

// ============================================================================
// WALLET & PORTFOLIO TRACKING
// ============================================================================

/// Carteiras registradas do usuário (TON, EVM, Smart Wallet, etc.)
model Wallet {
  id          String   @id @default(uuid())
  userId      String
  chain       String   // TON, ETHEREUM, BASE, POLYGON, ARBITRUM, AVALANCHE, etc.
  address     String
  walletType  String   // ton, evm, smart_wallet, panorama_wallet
  name        String?  // Apelido dado pelo usuário
  isPrimary   Boolean  @default(false)
  isActive    Boolean  @default(true)
  metadata    Json?    // Dados extras (session key info para smart wallet, etc.)
  tenantId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user              User               @relation(fields: [userId], references: [userId])
  positionSnapshots PositionSnapshot[]
  transactions      Transaction[]

  @@unique([userId, chain, address])
  @@index([userId, isActive])
  @@index([chain, address])
  @@index([tenantId])
}

/// Snapshot de posições do usuário (balance, lending, staking, LP, etc.)
model PositionSnapshot {
  id                String   @id @default(uuid())
  userId            String
  walletId          String
  chain             String

  // Protocolo e tipo
  protocol          String   // wallet, aave, compound, lido, benqi, uniswap, etc.
  market            String?  // Pool específico (ex: "USDC-ETH", "aUSDC")
  positionType      String   // balance, supply, borrow, stake, lp, derivative, reward

  // Asset
  assetAddress      String
  assetSymbol       String
  assetDecimals     Int

  // Valores
  amountRaw         String   // Wei string (precisão total)
  amountDisplay     String   // Formatado para exibição
  amountUsd         String?  // Valor em USD no momento do snapshot
  priceUsd          String?  // Preço unitário em USD

  // Dados específicos de protocolo
  accruedRaw        String?  // Juros/rewards acumulados (wei)
  accruedDisplay    String?  // Juros formatados
  apy               String?  // APY atual (ex: "5.25")
  healthFactor      String?  // Para lending (ex: "1.85")

  // Metadados do snapshot
  snapshotBlock     BigInt?
  snapshotTimestamp DateTime
  source            String   // onchain, cached, api

  // Sistema
  metadata          Json?    // Dados extras específicos do protocolo
  tenantId          String
  createdAt         DateTime @default(now())

  wallet Wallet @relation(fields: [walletId], references: [id])

  @@index([userId, snapshotTimestamp(sort: Desc)])
  @@index([walletId, protocol])
  @@index([userId, chain, positionType])
  @@index([tenantId])
}

/// Histórico de transações (swap, bridge, stake, lend, etc.)
model Transaction {
  id               String   @id @default(uuid())
  userId           String
  walletId         String
  conversationId   String?  // Link com o chat (se originado de conversa)

  // Ação
  action           String   // swap, bridge, stake, unstake, supply, withdraw, borrow, repay, claim, approve
  protocol         String?  // uniswap, aave, lido, layerswap, thirdweb, etc.

  // From (origem)
  fromChainId      Int
  fromAssetAddress String
  fromAssetSymbol  String
  fromAssetDecimals Int
  fromAmountRaw    String   // Wei
  fromAmountDisplay String
  fromAmountUsd    String?

  // To (destino) - nullable para operações single-sided (approve, claim)
  toChainId        Int?
  toAssetAddress   String?
  toAssetSymbol    String?
  toAssetDecimals  Int?
  toAmountRaw      String?  // Wei (estimado ou real)
  toAmountDisplay  String?
  toAmountUsd      String?

  // Execução
  txHashes         Json     // Array de { hash, chainId, type, status }
  status           String   @default("created") // created, submitted, pending, confirmed, failed, refunded
  provider         String?  // thirdweb, layerswap, direct, etc.

  // Taxas
  gasFee           String?  // Wei
  bridgeFee        String?  // Wei
  protocolFee      String?  // Wei
  totalFeeUsd      String?

  // Exchange info
  exchangeRate     String?  // Taxa de câmbio
  slippage         String?  // Slippage configurado (ex: "0.5")
  priceImpact      String?  // Price impact (ex: "0.12")

  // Erro
  errorCode        String?
  errorMessage     String?

  // Bridge específico
  bridgeId         String?  // ID externo do bridge (ex: Layerswap swapId)

  // Metadados
  metadata         Json?    // Dados extras
  tenantId         String
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  confirmedAt      DateTime?

  wallet        Wallet         @relation(fields: [walletId], references: [id])
  notifications Notification[]

  @@index([userId, createdAt(sort: Desc)])
  @@index([walletId, action])
  @@index([status])
  @@index([bridgeId])
  @@index([tenantId])
}

/// Notificações do usuário
model Notification {
  id            String   @id @default(uuid())
  userId        String
  transactionId String?  // Link com transação (se aplicável)

  // Conteúdo
  type          String   // tx_confirmed, tx_failed, health_warning, price_alert, dca_executed, stake_matured, welcome
  title         String
  message       String
  payload       Json?    // Dados extras para o frontend

  // Prioridade e ação
  priority      String   @default("medium") // low, medium, high, urgent
  actionUrl     String?  // URL para navegar ao clicar
  actionLabel   String?  // Texto do botão de ação

  // Estado
  isRead        Boolean  @default(false)
  isDismissed   Boolean  @default(false)

  // Sistema
  expiresAt     DateTime? // Notificação expira após esta data
  tenantId      String
  createdAt     DateTime @default(now())
  readAt        DateTime?

  transaction Transaction? @relation(fields: [transactionId], references: [id])

  @@index([userId, isRead, createdAt(sort: Desc)])
  @@index([userId, type])
  @@index([tenantId])
}

model Diagram {
  id        String   @id @default(uuid())
  name      String   @default("default") @unique
  nodes     Json
  edges     Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

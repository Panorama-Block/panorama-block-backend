#!/bin/bash

# PanoramaBlock E2E Test Utilities
# This file contains shared utility functions for all E2E tests

# Color constants for output formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Service URLs (can be overridden by environment variables)
AUTH_SERVICE_URL="${AUTH_SERVICE_URL:-http://localhost:3001}"
WALLET_TRACKER_URL="${WALLET_TRACKER_URL:-http://localhost:3000}"
LIQUID_SWAP_URL="${LIQUID_SWAP_URL:-http://localhost:3002}"

# Default test wallet address for authentication testing
TEST_ADDRESS="0xB5Cc5765a722B0ce3dFA7950cEC033D2Eb90aac5"

# Temporary directory for test files
TEMP_DIR="/tmp/panorama-e2e-tests"

# Test counters
TESTS_RUN=0
TESTS_PASSED=0

# Utility functions for formatted output
print_header() {
    echo -e "\n${BLUE}=== $1 ===${NC}"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

print_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

print_test_result() {
    local test_name="$1"
    local success="$2"
    local details="$3"
    
    TESTS_RUN=$((TESTS_RUN + 1))
    
    if [ "$success" = "true" ]; then
        TESTS_PASSED=$((TESTS_PASSED + 1))
        print_success "Test: $test_name"
        [ -n "$details" ] && echo "  $details"
    else
        print_error "Test: $test_name"
        [ -n "$details" ] && echo "  $details"
    fi
}

# Initialize temporary directory for test files
init_temp_dir() {
    mkdir -p "$TEMP_DIR"
    print_info "Temporary directory created: $TEMP_DIR"
}

# Clean up temporary directory
cleanup_temp_dir() {
    if [ -d "$TEMP_DIR" ]; then
        rm -rf "$TEMP_DIR"
        print_info "Temporary directory cleaned up"
    fi
}

# Wait for a service to be ready
wait_for_service() {
    local url="$1"
    local service_name="$2"
    local timeout="${3:-30}"
    local interval="${4:-2}"
    
    print_info "Waiting for $service_name to be ready..."
    
    for i in $(seq 1 $((timeout / interval))); do
        if curl -s "$url/health" > /dev/null 2>&1; then
            print_success "$service_name is ready"
            return 0
        fi
        sleep $interval
    done
    
    print_error "$service_name failed to start within ${timeout}s"
    return 1
}

# Check if jq is available for JSON processing
check_jq() {
    if ! command -v jq >/dev/null 2>&1; then
        print_error "jq is required but not installed"
        print_info "Install jq: sudo apt-get install jq"
        return 1
    fi
    return 0
}

# Check if Docker Compose is available
check_docker_compose() {
    if ! command -v docker-compose >/dev/null 2>&1; then
        print_error "docker-compose is required but not installed"
        return 1
    fi
    return 0
}

# Kill process on specific port
kill_port() {
    local port="$1"
    local pid=$(lsof -ti:$port 2>/dev/null)
    
    if [ -n "$pid" ]; then
        print_info "Killing process $pid on port $port"
        kill -9 $pid 2>/dev/null || true
        sleep 1
    fi
}

# Validate JSON response
validate_json() {
    local response="$1"
    
    if echo "$response" | jq . >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Extract field from JSON response
extract_json_field() {
    local response="$1"
    local field="$2"
    
    echo "$response" | jq -r "$field" 2>/dev/null
}

# Make HTTP request with curl and handle common scenarios
make_request() {
    local method="$1"
    local url="$2"
    local data="$3"
    local headers="$4"
    local timeout="${5:-10}"
    
    local curl_cmd="curl -s --max-time $timeout -X $method"
    
    if [ -n "$headers" ]; then
        curl_cmd="$curl_cmd $headers"
    fi
    
    if [ -n "$data" ] && [ "$method" != "GET" ]; then
        curl_cmd="$curl_cmd -d '$data'"
    fi
    
    curl_cmd="$curl_cmd '$url'"
    
    eval $curl_cmd 2>/dev/null
}

# Generate mock wallet signature for testing
generate_mock_signature() {
    local payload="$1"
    
    # This is a mock signature for testing purposes only
    # In a real scenario, this would be generated by a wallet
    echo "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1b"
}

# Test auth service health endpoint
test_auth_health() {
    local response=$(make_request "GET" "$AUTH_SERVICE_URL/health")
    local status_code=$(curl -s -o /dev/null -w "%{http_code}" "$AUTH_SERVICE_URL/health")
    
    if [ "$status_code" = "200" ] && validate_json "$response"; then
        print_test_result "Auth Service Health Check" "true" "Status: $status_code"
        return 0
    else
        print_test_result "Auth Service Health Check" "false" "Status: $status_code, Response: $response"
        return 1
    fi
}

# Test wallet tracker service health endpoint
test_wallet_tracker_health() {
    local response=$(make_request "GET" "$WALLET_TRACKER_URL/health")
    local status_code=$(curl -s -o /dev/null -w "%{http_code}" "$WALLET_TRACKER_URL/health")
    
    if [ "$status_code" = "200" ]; then
        print_test_result "Wallet Tracker Health Check" "true" "Status: $status_code"
        return 0
    else
        print_test_result "Wallet Tracker Health Check" "false" "Status: $status_code, Response: $response"
        return 1
    fi
}

# Test liquid swap service health endpoint
test_liquid_swap_health() {
    local response=$(make_request "GET" "$LIQUID_SWAP_URL/health")
    local status_code=$(curl -s -o /dev/null -w "%{http_code}" "$LIQUID_SWAP_URL/health")
    
    if [ "$status_code" = "200" ] && validate_json "$response"; then
        print_test_result "Liquid Swap Health Check" "true" "Status: $status_code"
        return 0
    else
        print_test_result "Liquid Swap Health Check" "false" "Status: $status_code, Response: $response"
        return 1
    fi
}

# Save test results to file
save_test_results() {
    local test_suite="$1"
    local timestamp=$(date '+%Y%m%d-%H%M%S')
    local report_file="/tmp/panorama-e2e-report-$timestamp.txt"
    
    cat > "$report_file" << EOF
PanoramaBlock E2E Test Report
Generated: $(date)
Test Suite: $test_suite

Summary:
- Total Tests: $TESTS_RUN
- Passed: $TESTS_PASSED
- Failed: $((TESTS_RUN - TESTS_PASSED))
- Success Rate: $(( TESTS_PASSED * 100 / TESTS_RUN ))%

Service URLs:
- Auth Service: $AUTH_SERVICE_URL
- Wallet Tracker: $WALLET_TRACKER_URL
- Liquid Swap: $LIQUID_SWAP_URL

Test Environment:
- Test Address: $TEST_ADDRESS
- Temporary Directory: $TEMP_DIR
EOF
    
    print_info "Test results saved to: $report_file"
}

# Performance testing utility
measure_response_time() {
    local url="$1"
    local method="${2:-GET}"
    local data="$3"
    
    local start_time=$(date +%s%3N)
    local response=$(make_request "$method" "$url" "$data")
    local end_time=$(date +%s%3N)
    
    local duration=$((end_time - start_time))
    echo "$duration"
}

# Load testing utility - run multiple concurrent requests
load_test() {
    local url="$1"
    local concurrent_requests="${2:-5}"
    local method="${3:-GET}"
    local data="$4"
    
    print_info "Running load test: $concurrent_requests concurrent requests to $url"
    
    local pids=()
    local temp_file_base="$TEMP_DIR/load_test_$$"
    
    # Start concurrent requests
    for i in $(seq 1 $concurrent_requests); do
        (
            local response_time=$(measure_response_time "$url" "$method" "$data")
            echo "$response_time" > "${temp_file_base}_$i"
        ) &
        pids+=($!)
    done
    
    # Wait for all requests to complete
    for pid in "${pids[@]}"; do
        wait $pid
    done
    
    # Calculate statistics
    local total_time=0
    local max_time=0
    local min_time=999999
    local successful_requests=0
    
    for i in $(seq 1 $concurrent_requests); do
        if [ -f "${temp_file_base}_$i" ]; then
            local time=$(cat "${temp_file_base}_$i")
            total_time=$((total_time + time))
            
            if [ $time -gt $max_time ]; then
                max_time=$time
            fi
            
            if [ $time -lt $min_time ]; then
                min_time=$time
            fi
            
            successful_requests=$((successful_requests + 1))
            rm -f "${temp_file_base}_$i"
        fi
    done
    
    if [ $successful_requests -gt 0 ]; then
        local avg_time=$((total_time / successful_requests))
        print_info "Load test results: $successful_requests/$concurrent_requests successful"
        print_info "Response times - Min: ${min_time}ms, Max: ${max_time}ms, Avg: ${avg_time}ms"
        
        return 0
    else
        print_error "Load test failed: No successful requests"
        return 1
    fi
}

# Export functions for use in other scripts
export -f print_header print_success print_error print_warning print_info print_test_result
export -f init_temp_dir cleanup_temp_dir wait_for_service check_jq check_docker_compose
export -f kill_port validate_json extract_json_field make_request generate_mock_signature
export -f test_auth_health test_wallet_tracker_health test_liquid_swap_health
export -f save_test_results measure_response_time load_test 